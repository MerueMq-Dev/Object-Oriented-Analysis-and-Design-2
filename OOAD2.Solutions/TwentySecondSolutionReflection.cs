using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OOAD2.Solutions
{
    public class TwentySecondSolutionReflection
    {
       // Моё решение демонстрирует наследование вида на более практичном примере. В нём есть две равнозначные характеристики 
       // напитка — тип(кофе, чай, сок) и размер порции(маленький, средний, большой). Ни одна из этих характеристик не важнее другой, и
       // их можно комбинировать независимо.Это позволяет создавать любые комбинации напитков и размеров без множества подклассов 
       // вроде «Большой кофе» или «Маленький чай» и без лишних проверок типа «если это кофе и размер большой». Добавление нового напитка
       // или размера требует всего одного нового класса, без изменения существующего кода.
       // Решения других студентов тоже правильные. В Java-примере форма одежды и материал вынесены в отдельные иерархии и объединены в 
       // классе одежды через композицию. В Python-примере раса и игровой класс героя реализованы отдельно, а класс Hero объединяет их. 
       // Оба подхода корректно показывают идею наследования вида — объект описывается сразу несколькими независимыми характеристиками.   
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OOAD2.Solutions
{
    public class TwentyFirstSolutionReflection
    {
        // Моё решение получилось более практичным и жизненным по сравнению с примерами других студентов. В части наследования реализации 
        // мой пример показывает реальный сценарий: родительский класс уже умеет выполнять повторные попытки, а потомок просто пользуется этой готовой
        // логикой. У других студентов пример с деревом более учебный и почти не показывает реальную необходимость наследования.
        // Во втором примере я демонстрирую льготное наследование через доменные исключения: новый класс просто использует уже заданную структуру
        // ошибки и не добавляет ничего своего — это полностью соответствует идее такого вида наследования. В работах других студентов примеры проще, 
        // а один даже выбивается по смыслу. Пример на Python подходит, хоть и очень простой, потому что там потомок действительно только меняет данные.
        // Но пример на Java уже не соответствует сути льготного наследования: там наследник добавляет новые поля и фактически расширяет поведение,
        // что превращает пример в обычное расширяющее наследование.Именно поэтому мои примеры точнее и лучше отражают задуманные принципы.
    }
}
